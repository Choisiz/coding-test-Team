## 1987번 알파벳

### 난이도

> 골드4

### 문제

세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.

### 입력

첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.

### 출력

첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.

### 예제 입력 1 복사

```
2 4
CAAB
ADCB
```

### 예제 출력 1 복사

```
3
```

### 예제 입력 2 복사

```
3 6
HFDFFB
AJHGDH
DGAGEH
```

### 예제 출력 2 복사

```
6
```

### 풀이

문제를 보면 알파벳 경로를 지나가는데 중복된 알파벳은 허용하지 않는다.
이것은 답을 찾는 경로중 답이 아닐것 같으면 그 경로는 가지 않는
방식인 백트래킹 알고리즘을 나타내고 있다. 즉 불필요한 경로, 알파벳이
중복되는 경로를 가지 않는다는 것이다.
때문에 백트래킹을 이용해야 하는데, 남의 코드를 보고서야 백트래킹의 사용법을
알았다. 간단히 이야기해서 dfs에 조건을 걸어 끝까지 가는 깊이경로를 차단해주는것이다.

이 문제에서는 알파벳을 우선 ord를 이용하여
graph 배열에 데이터를 숫자로 변형해주었고,
arr이라는 0으로 이루어진 배열을 알파벳갯수 26개만큼 만들었다.
arr의 인덱스에 graph의 좌표를 넣어서, 알파벳의 따른 arr 인덱스를 가르키게 만들었다.

> ex: graph[0][2] =C 일때 ord에 의해 c=2이므로
> arr은 [0,0,1,0,0,...]로 3번째 인덱스 자리가 1로 채워줬다.

dfs 함수는 for문을 4번돌아 상,하,좌,우의 데이터를 찾을수 있게했고,
nx,ny에 상하좌우 좌표를 넣어, grapy[nx][ny]의 값을 찾게했고,
그값이 arr의 인덱스가 되는데, 그게 0, 즉 1이 되면, 해당 알파벳의
경로를 지났단 말인데, 0이면 중복되지 않는단 소리이므로,
arr의 그 값을 1로 처리해줘 알파벳을 지나갔다는 표현을 해주고,
재귀로 dfs를 넣어주어 깊게 들어가게 하였다. 여기서, z에 +1을
해주어 1씩 증가되어 만들어 주어 해당경로의 최대값을 구하게 만들었다.
마지막에는 다시 arr을 0으로 바꾸어주어, dfs가 다시 돌아오게 하였다.
(좀더 좋은말이 생각이 안남..)
참고로 bfs는 큐에 graph[x][y]값을 계속더하는 방식
a..ab..abc 이런식의 방식을 사용해서 구했다.
