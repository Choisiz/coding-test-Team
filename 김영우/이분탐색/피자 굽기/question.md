# 피자 굽기

## 문제

- 월드피자 원주 지점에서 N개의 피자 반죽을 오븐에 넣고 구우려고 한다. 그런데, 월드피자에서 만드는 피자 반죽은 지름이 제각각이다. 그런가하면, 월드피자에서 사용하는 오븐의 모양도 몹시 오묘하다. 이 오븐은 깊은 관처럼 생겼는데, 관의 지름이 깊이에 따라 들쭉날쭉하게 변한다. 아래는 오븐의 단면 예시이다.

![image](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201006/pizz1.PNG)  

- 피자 반죽은 완성되는 순서대로 오븐에 들어간다. 이렇게 N개의 피자가 오븐에 모두 들어가고 나면, 맨 위의 피자가 얼마나 깊이 들어가 있는지가 궁금하다. 이를 알아내는 프로그램을 작성하시오.

## 입력

- 첫째 줄에 오븐의 깊이 D와 피자 반죽의 개수 N이 공백을 사이에 두고 주어진다. (1 ≤ D, N ≤ 300,000) 둘째 줄에는 오븐의 최상단부터 시작하여 깊이에 따른 오븐의 지름이 차례대로 주어진다. 셋째 줄에는 피자 반죽이 완성되는 순서대로, 그 각각의 지름이 주어진다. 오븐의 지름이나 피자 반죽의 지름은 10억 이하의 자연수이다.



## 출력

- 첫째 줄에, 마지막 피자 반죽의 위치를 출력한다. 오븐의 최상단이 1이고, 최하단 가장 깊은 곳이 D이 된다. 만약 피자가 모두 오븐에 들어가지 않는다면, 0을 출력한다.

## 제한 

- 

## 예제

input
``` 
7 3
5 6 4 3 6 2 3
3 2 5
```
output
``` 
2
```

## 알고리즘 풀이

> 조금 다른 방식으로 풀다가 기본 배열을 점점 작아지는 구조로 만들어버린 후에 binary search를 돌리면 된다는 것을 알았다.  
> 그런데 배열 구조 만드는 것을 잘못 만들었었나보다..........  
> 이게 틀린 줄도 모르고 온갖 삽질을 다해봐도 틀려서 binary search와 솔루션 코드가 결국 인터넷 코드와 비슷하게 되었다.  
> 그런데도 틀리니까 처음부터 map을 잘못구현한 걸 깨달았다......    
> ㅏ......   

1. map으로 배열 구조를 점점 작아지게 바꾼다.
```
5 6 4 3 6 2 3  
-> 5 5 4 3 3 2 2  
```
2. 이분탐색으로 **배열 숫자** 중 **찾는 숫자** 보다 **작은** 가장 **첫번째 숫자**가 있는 인덱스를 리턴한다.
   - **보통은 동일한 결과값을 찾으므로 ===을 사용해서 중간에 끊는데 이 경우에는 모든 이분탐색을 다 돌아야 찾아진다**
3. 리턴한 인덱스(nowIndex) 바로 위쪽으로 피자가 쌓이므로 endIndex를 nowIndex - 1로 만들고 모든 피자를 쌓을 때까지 이분탐색을 실행한다.

