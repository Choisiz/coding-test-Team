```py
from collections import deque
import sys

sys.setrecursionlimit(10 ** 4)
input = sys.stdin.readline


def dfs(x, y):
    graph[x][y] = -1  # 외부 공기 처리
    for i in range(4):
        px = x + dx[i]
        py = y + dy[i]
        # 모눈종이 내
        if 0 <= px and px < n and 0 <= py and py < m:
            # 외부 공기인 경우
            if graph[px][py] == 0:
                dfs(px, py)


n, m = map(int, input().split())

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
graph = []
q = deque()
ans = 0  # 최종 걸리는 시간
# 모눈종이 정보 입력
for i in range(n):
    graph.append(list(map(int, input().split())))
    for j in range(m):
        # 치즈위치 저장
        if graph[i][j] == 1:
            q.append((i, j))

dfs(0, 0)  # 외부공기 -1로 처리

# 큐가 빌때까지 반복 -> 치즈가 남아있으면 반복
while q:
    length = len(q)
    loop = 0
    changed = []  # 녹는 지점
    ans += 1 # 소요시간
    # 큐의 길이만큼 반복
    while loop < length:
        x, y = q.popleft()
        cnt = 0
        for i in range(4):
            px = x + dx[i]
            py = y + dy[i]
            # 4면 중 외부공기와 닿는 면 개수 확인
            if graph[px][py] == -1:
                cnt += 1

        # 2면 이상 닿으면
        if cnt >= 2:
            graph[x][y] = 3  # 녹음 처리
            changed.append((x, y))
        # 2면 미만 닿으면
        else:
            q.append((x, y))  # 다시 큐에 삽입

        loop += 1
    # 녹는 지점을 기준으로 4방향에 내부공기가 있다면 외부공기로 수정
    # 녹는 지점도 외부공기로 처리
    for x, y in changed:
        dfs(x, y)

print(ans)
```
